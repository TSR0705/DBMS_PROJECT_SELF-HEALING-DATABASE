╔════════════════════════════════════════════════════════════════════════════╗
║    PHASE 2, STEP 1: AI-ASSISTED SELF-HEALING DBMS SCHEMA DESIGN             ║
║                        QUICK REFERENCE CARD                                 ║
╚════════════════════════════════════════════════════════════════════════════╝

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
THE 8 TABLES AT A GLANCE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────────────────────────────────────────────────────────────┐
│ 1. detection_events (DBMS → Raw Detection)                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│   • What: MySQL detections (Performance Schema, slow logs, deadlocks)        │
│   • Immutable: Append-only log                                              │
│   • Key Fields: event_id, detection_source, target_resource, metric_value   │
│   • Status: Always "recorded" (no state machine)                            │
│   • Purpose: Source of truth for what DBMS observed                         │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 2. detected_issues (Categorized Problems)                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│   • What: Categorized problem from events (QUERY_PERFORMANCE, DEADLOCK)     │
│   • Mutable: Status changes (DETECTED → RESOLVED)                           │
│   • Key Fields: issue_id, issue_category, occurrence_count, issue_status    │
│   • Status: DETECTED → UNDER_ANALYSIS → APPROVED → EXECUTING → RESOLVED    │
│   • Purpose: Aggregates events into actionable issues                       │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 3. ai_analysis (AI Interpretation)                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│   • What: AI's best guess at root cause + confidence (0.00-1.00)            │
│   • Multiple per issue: Can re-analyze with new data                        │
│   • Key Fields: analysis_id, confidence_score, root_cause_hypothesis        │
│   • Status: RECOMMENDATION_ISSUED → DECISION_PENDING → DECISION_APPROVED    │
│   • Purpose: Inform human decisions (not make them)                         │
│   • Data Type: DECIMAL(3,2) for confidence (not FLOAT!)                     │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 4. predefined_actions (Safety Whitelist)                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│   • What: Catalog of safe, pre-approved actions (MASTER DATA)               │
│   • No dynamics: All actions must be in this table; no dynamic SQL          │
│   • Key Fields: action_id, action_name, execution_query, risk_level         │
│   • Examples: "analyze_table", "add_missing_index", "kill_query"            │
│   • Purpose: Prevent arbitrary SQL execution                                │
│   • No status: Static reference data                                        │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 5. recovery_decisions (AI Recommendations)                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│   • What: AI recommends a specific predefined action                        │
│   • Status: PENDING_APPROVAL (awaits human) until admin_approvals created  │
│   • Key Fields: decision_id, analysis_id, recommended_action_id             │
│   • Status: PENDING → APPROVED or DECLINED (in admin_approvals)            │
│   • Purpose: Link analysis to action; not a decision yet (awaits approval) │
│   • One per analysis usually; may have multiple if admin rejects first one  │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 6. admin_approvals (THE MANDATORY CHECKPOINT)                               │
├─────────────────────────────────────────────────────────────────────────────┤
│   • What: HUMAN DECISION (approve/decline recovery_decision)                │
│   • Mandatory: Cannot execute without this                                  │
│   • Key Fields: approval_id, admin_user_id, approval_status, approval_reason│
│   • Status: APPROVED → execution; DECLINED → issue closed or re-analyze     │
│   • Reason: CONFIDENT, ROUTINE, SKEPTICAL_BUT_APPROVED, SAFETY_CONCERN     │
│   • Purpose: Irreplaceable human oversight; no bypass possible              │
│   • FK Constraint: action_executions MUST have approval_id (NOT NULL)       │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 7. action_executions (What Actually Happened)                               │
├─────────────────────────────────────────────────────────────────────────────┤
│   • What: Actual execution of approved actions + outcomes                   │
│   • Immutable: Once completed, logs what happened                           │
│   • Key Fields: execution_id, approval_id, action_id, execution_outcome     │
│   • Status: QUEUED → IN_PROGRESS → COMPLETED or FAILED                     │
│   • Outcome: SUCCESS, PARTIAL_SUCCESS, FAILED, ROLLED_BACK                 │
│   • Purpose: Immutable log of actions performed and results                 │
│   • FK Constraint: Must have approval_id (no execution without approval)    │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ 8. learning_records (ML Training Data)                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│   • What: Historical outcomes; ML learns from this                          │
│   • Read-Only for ML: ML cannot write to recovery_decisions                 │
│   • Key Fields: learning_record_id, issue_id, execution_id, issue_resolved  │
│   • Metrics: metric_improvement_percent, confidence_accuracy, would_approve │
│   • Status: learning_complete = FALSE (not ready) or TRUE (ready for ML)    │
│   • Purpose: Feed ML model training; never control execution                │
│   • Critical: learning_complete prevents premature ML ingestion             │
└─────────────────────────────────────────────────────────────────────────────┘

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
THE 5 CRITICAL FOREIGN KEYS (Memorize These!)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. recovery_decisions.action_id → predefined_actions.action_id
   ✓ Prevents arbitrary SQL (only predefined actions allowed)
   ✓ Criticality: HIGH (safety guarantee)

2. recovery_decisions.analysis_id → ai_analysis.analysis_id
   ✓ Ensures decision has rationale
   ✓ Criticality: MEDIUM (audit trail)

3. admin_approvals.decision_id → recovery_decisions.decision_id (NOT NULL)
   ✓ Every execution must be approved
   ✓ Criticality: CRITICAL (core safety)

4. action_executions.approval_id → admin_approvals.approval_id (NOT NULL)
   ✓ Impossible to execute without approval (FK violation)
   ✓ Criticality: CRITICAL (hardest safety guarantee)

5. action_executions.action_id → predefined_actions.action_id
   ✓ Only predefined actions execute
   ✓ Criticality: CRITICAL (prevents arbitrary SQL)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
WORKFLOW SEQUENCE (Cannot Skip Stages)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. DBMS Detects
   ├─ INSERT detection_events
   ├─ Immutable log; contains raw_context (JSON)
   └─ No AI involvement yet

2. Issue Categorized
   ├─ INSERT detected_issues
   ├─ Status: DETECTED
   └─ References detection_events

3. AI Analyzes
   ├─ INSERT ai_analysis
   ├─ confidence_score (0.00-1.00)
   ├─ root_cause_hypothesis
   └─ Status: RECOMMENDATION_ISSUED (not a decision!)

4. AI Recommends
   ├─ INSERT recovery_decisions
   ├─ Recommends a predefined_action
   ├─ Status: PENDING_APPROVAL
   └─ Awaits human review

5. HUMAN APPROVES (Cannot be automated)
   ├─ INSERT admin_approvals
   ├─ admin_user_id, approval_reason recorded
   ├─ approval_status: APPROVED or DECLINED
   └─ ONLY if APPROVED → next stage possible

6. Action Executes
   ├─ Only if admin_approvals.approval_status = APPROVED
   ├─ INSERT action_executions
   ├─ Fetch predefined action
   ├─ Execute SQL (validated parameters)
   └─ Record outcome (SUCCESS/FAILED)

7. Learning Recorded
   ├─ INSERT learning_records
   ├─ issue_resolved_flag (human assessed)
   ├─ metric_improvement_percent
   ├─ confidence_accuracy (calibration)
   └─ learning_complete (ready for ML training)

8. ML Retrains (External Process)
   ├─ Reads learning_records
   ├─ Cannot write to recovery_decisions
   ├─ Improves confidence calibration
   └─ Better recommendations next time (same workflow)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
SAFETY GUARANTEES (What's Impossible?)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

IMPOSSIBLE: AI executes without admin approval
   └─ Prevented by: FK action_executions.approval_id → admin_approvals (NOT NULL)
   └─ Test: INSERT action_executions (approval_id=NULL) → ERROR FK constraint

IMPOSSIBLE: Arbitrary SQL executed
   └─ Prevented by: FK recovery_decisions.action_id → predefined_actions
   └─ Test: INSERT recovery_decisions (action_id=9999) → ERROR FK constraint

IMPOSSIBLE: ML overrides human decision
   └─ Prevented by: learning_records is read-only for ML
   └─ No FK from learning_records back to recovery_decisions
   └─ Test: ML can read learning_records; cannot write to recovery_decisions

IMPOSSIBLE: Approval changed after execution started
   └─ Prevented by: action_executions.approval_id immutable FK
   └─ Once execution created, approval cannot be withdrawn (referential integrity)

IMPOSSIBLE: Execution hidden from audit
   └─ Prevented by: action_executions records all executions
   └─ Timestamps server-side (tamper-proof)
   └─ Query: SELECT * FROM action_executions WHERE execution_status = 'COMPLETED'

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
VIVA LIGHTNING ROUND ANSWERS (30 seconds each)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Q: "Why 8 tables?"
A: "Separation of concerns enforced at database level. Each stage (detection,
   analysis, decision, approval, execution, learning) has clear boundaries. Merging
   tables would remove decision points and safety checkpoints."

Q: "How prevent AI execution?"
A: "Foreign key NOT NULL: action_executions.approval_id → admin_approvals.
   Cryptographically impossible to execute without approval record."

Q: "Why DECIMAL(3,2) not FLOAT?"
A: "Precision. 0.95 in FLOAT might store as 0.94999... causing checks to fail.
   DECIMAL stores 0.95 exactly. Audit logs require precision."

Q: "How ML learn safely?"
A: "learning_records is read-only for ML. ML reads outcomes; cannot write to
   recovery_decisions. ML improves confidence calibration only."

Q: "Most critical FK?"
A: "action_executions.approval_id → admin_approvals (NOT NULL).
   Makes execution without approval impossible."

Q: "How handle failures?"
A: "execution_outcome records FAILED. learning_records assesses if worth retrying.
   Next recommendation might try different action."

Q: "How prevent rubber-stamping?"
A: "approval_reason enum forces documentation. Query reveals patterns (100 approvals,
   0 declines). Whitelist of predefined_actions limits damage."

Q: "How ensure no stale approvals?"
A: "Timestamps on admin_approvals and action_executions. Can detect if approval
   hour before execution vs. after. Operational control + audit trail."

Q: "Confidence accuracy meaning?"
A: "Compares AI confidence (0.95) to actual outcome success. If AI confident
   but fails, model poorly calibrated. ML learns this mismatch."

Q: "What if issue recurs?"
A: "New detected_issues.issue_id created. learning_records shows action wasn't
   effective. Next time, AI recommends different action or notes 'needs reapplication'."

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
DATA TYPE JUSTIFICATIONS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

BIGINT UNSIGNED for IDs
  → Supports 18+ billion records (audit logs are huge)
  → Prevents overflow; same as INT won't cut it

TIMESTAMP(6) for all timestamps
  → Microsecond precision (critical for temporal ordering)
  → Server-side (tamper-proof; application time is unreliable)
  → Automatically updated on INSERT

DECIMAL(3, 2) for confidence
  → Exact decimal (not binary approximation like FLOAT)
  → 0.00 to 9.99 range (sufficient for 0.00-1.00)
  → Comparison operators work reliably

ENUM for status fields
  → Restricts to valid states (cannot insert invalid status)
  → Compact storage (1-2 bytes vs. VARCHAR)
  → Forces consistent terminology

JSON for raw_context and metrics
  → Variable schema per event/execution
  → No 1:N explosion of detail tables
  → MySQL native; supports extraction functions

VARCHAR(255) for names
  → Sufficient for DBMS resource names
  → Resource names longer than 255 are unusual
  → Can increase if needed

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
NORMALIZATION: WHY 3NF?
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1NF ✓
  Every column is atomic (not repeating groups)
  Examples: issue_id alone uniquely identifies issue

2NF ✓
  Every non-key attribute depends on full primary key
  Example: analysis_id → confidence_score (depends on analysis_id, not issue_id)

3NF ✓
  No transitive dependencies
  Example: issue_id → issue_created_at (direct, not transitive)

Denormalization (Acceptable):
  • occurrence_count in detected_issues
    → Avoids expensive COUNT() every query
    → Updated atomically; no consistency risk
  • post_execution_metrics as JSON
    → Variable schema; normalization would explode tables
    → Read-heavy use case; denormalization acceptable

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
IF EXAMINER CHALLENGES YOUR DESIGN
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Challenge: "Why not use NoSQL?"
Response: "This is a DBMS system; relational model ensures referential integrity
          and ACID transactions. NoSQL lacks foreign key constraints critical
          for preventing unsafe execution."

Challenge: "Why not let AI modify analysis?"
Response: "Audit integrity. Analysis timestamps must be immutable. If AI could
          update analysis after approval, we couldn't trace decision rationale.
          Better to create new ai_analysis row if re-analyzing."

Challenge: "Why not single 'logs' table?"
Response: "Generic logs lose structure. Each stage has different schema. Query
          for 'pending decisions' requires WHERE decision_status = 'PENDING_APPROVAL',
          impossible with generic table."

Challenge: "Why not store confidence as INT 0-100?"
Response: "Precision. 95/100 = 0.95 exactly in DECIMAL. In INT, 95 might mean
          95.something. DECIMAL prevents off-by-one ambiguity in comparisons."

Challenge: "Can ML be trusted with learning_records?"
Response: "ML is read-only. learning_records have no FK back to recovery_decisions.
          ML cannot create decisions or approvals. Only improves confidence
          calibration, which feeds better recommendations (still requires approval)."

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PRINT THIS CARD & BRING TO VIVA
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

This card contains:
✓ All 8 tables explained in 1 paragraph each
✓ 5 critical FK constraints you must memorize
✓ Workflow sequence (cannot skip stages)
✓ 5 safety guarantees (what's impossible?)
✓ 10 likely viva questions + 30-second answers
✓ Data type justifications
✓ Normalization summary
✓ Challenge responses

You're ready. Good luck!

╔════════════════════════════════════════════════════════════════════════════╗
║                    PHASE 2, STEP 1 SCHEMA COMPLETE                        ║
║              Status: VIVA READY | Confidence: HIGH                         ║
╚════════════════════════════════════════════════════════════════════════════╝
